<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advent of code 2024 day 6 part 1</title>
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      canvas {
        display: block;
        margin: 0 auto;
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <h1>Advent of code 2024 day 6 part 1</h1>
    <canvas id="playground" width="780" height="780"></canvas>
    <script>
      window.onload = init;
      const tileSize = 6;
      const FPS = 60;
      const interval = 1000 / FPS;
      const obstacle = "#";
      const visited = "X";
      const empty = ".";
      const directions = {
        TOP: "TOP",
        BOTTOM: "BOTTOM",
        LEFT: "LEFT",
        RIGHT: "RIGHT",
      };
      const player = {
        x: 0,
        y: 0,
        speed: 1,
        direction: directions.TOP,
        sprite: "^",
        checkifVisited: function () {
          return map[this.y][this.x] === visited;
        },
        checkObstacle: function (x, y) {
          return map[y][x] === obstacle;
        },
        update: function (delta) {
          switch (this.direction) {
            case directions.TOP:
              newPos = this.y - this.speed;
              if (newPos < 0) {
                running = false
                break;
              }
              isCollision = this.checkObstacle(this.x, newPos);
              if (isCollision) {
                this.direction = directions.RIGHT;
              } else {
                this.y = newPos;
              }
              break;
            case directions.BOTTOM:
              newPos = this.y + this.speed;
              if (newPos >= map.yDistance) {
                running = false
                break;
              }
              isCollision = this.checkObstacle(this.x, newPos);
              if (isCollision) {
                this.direction = directions.LEFT;
              } else {
                this.y = newPos;
              }
              break;
            case directions.LEFT:
              newPos = this.x - this.speed;
              if (newPos < 0) {
                running = false
                break;
              }
              isCollision = this.checkObstacle(newPos, this.y);
              if (isCollision) {
                this.direction = directions.TOP;
              } else {
                this.x = newPos;
              }
              break;
            case directions.RIGHT:
              newPos = this.x + this.speed;
              if (newPos >= map.xDistance) {
                running = false
                break;
              }
              isCollision = this.checkObstacle(newPos, this.y);
              if (isCollision) {
                this.direction = directions.BOTTOM;
              } else {
                this.x = newPos;
              }
              break;
          }
        },
      };
      const tileset = {
        [obstacle]: {
          color: "green",
        },
        [empty]: {
          color: "black",
        },
        [player.sprite]: {
          color: "red",
        },
        [visited]: {
          color: "blue",
        },
      };
      let canvas;
      let context;
      let running = true
      let gameID;
      let delta = 0;
      let currentTime = 0;
      let lasTime = 0;
      let map = [];

      async function* makeTextFileLineIterator(fileURL) {
        const utf8Decoder = new TextDecoder("utf-8");
        let response = await fetch(fileURL);
        let reader = response.body.getReader();
        let { value: chunk, done: readerDone } = await reader.read();
        chunk = chunk ? utf8Decoder.decode(chunk, { stream: true }) : "";

        let re = /\r\n|\n|\r/gm;
        let startIndex = 0;

        for (;;) {
          let result = re.exec(chunk);
          if (!result) {
            if (readerDone) {
              break;
            }
            let remainder = chunk.substr(startIndex);
            ({ value: chunk, done: readerDone } = await reader.read());
            chunk =
              remainder +
              (chunk ? utf8Decoder.decode(chunk, { stream: true }) : "");
            startIndex = re.lastIndex = 0;
            continue;
          }
          yield chunk.substring(startIndex, result.index);
          startIndex = re.lastIndex;
        }
        if (startIndex < chunk.length) {
          // last line didn't end in a newline char
          yield chunk.substr(startIndex);
        }
      }

      function init() {
        (async function () {
          canvas = document.getElementById("playground");
          context = canvas.getContext("2d");
          gameID = requestAnimationFrame(gameLoop);
          let lineIndex = 0;
          for await (let line of makeTextFileLineIterator("../data/6.txt")) {
            const playerIndex = line.indexOf(player.sprite);
            if (playerIndex !== -1) {
              player.x = playerIndex;
              player.y = lineIndex;
            }
            lineIndex++;
            map.push([...line.split("")]);
          }
        })();
      }

      function gameLoop() {
        gameID = requestAnimationFrame(gameLoop);
        currentTime = new Date().getTime();
        delta = currentTime - lasTime;
        if (delta > interval) {
          context.fillStyle = "black";
          context.fillRect(0, 0, canvas.width, canvas.height);
          for (let i = 0; i < canvas.height; i += tileSize) {
            for (let j = 0; j < canvas.width; j += tileSize) {
              const originalIndexHeight = i / tileSize;
              const originalIndexWidth = j / tileSize;
              const item = map[originalIndexWidth][originalIndexHeight];
              context.fillStyle = tileset[item]?.color ?? "gray";
              context.fillRect(j, i, tileSize, tileSize);
            }
          }
          map[player.y][player.x] = visited;
          player.update(delta);
          map[player.y][player.x] = player.sprite;
          lasTime = currentTime - (delta % interval);
        }
        if (!running) {
          cancelAnimationFrame(gameID);
        }
      }
    </script>
  </body>
</html>
